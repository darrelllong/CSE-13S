\documentclass{article}
\usepackage{fullpage,fourier,amsmath,amssymb}
\usepackage{listings,color,url,hyperref}
\usepackage{mdframed}
\usepackage{clrscode3e}
\usepackage{parskip}
\usepackage{caption}
\captionsetup{labelformat=empty}
\usepackage[x11names]{xcolor}
\usepackage{forest}
\usepackage{tikz-qtree}
\usetikzlibrary{fit,backgrounds,shapes.multipart,calc,positioning}

\usepackage{epigraph}
\title{Assignment 7 \\ Lempel-Ziv Compression}
\author{Prof. Darrell Long \\
CSE 13S -- Winter 2021}
\date{Due: March 14\textsuperscript{th} at 11:59 pm PST}

\input{../lststyle}
\input{../footer}

\begin{document}\maketitle

\epigraphwidth=0.65\textwidth
\epigraph{\emph{Everyday, we create 2.5 quintillion bytes of data -- so much
that 90\% of the data in the world today has been created in the last two years
alone.}}{---IBM report on Big Data (2011)}

\section{Introduction}
Compressing data means reducing the number of bits needed to represent it.
Compressed data, due to its reduced size, is a lot faster to transfer and less
expensive to store, freeing up storage and increasing network capacity.
Algorithms that perform data compression are known as data compression
algorithms. Data compression algorithms are divided into two categories: lossy
and lossless.  Lossy compression algorithms compress more than lossless
compression algorithms, but at the cost of losing some information, which can't
be recovered. Lossy compression algorithms are typically used for audio and
video files, where a loss in quality is tolerable and often not noticeable.
Lossless compression algorithms on the other hand don't compress as much, but do
not lose any data, meaning compressed information can be exactly reconstructed
back into its uncompressed form. Lossless compression algorithms are used for
data that must maintain integrity, such as binaries, text documents, and source
code.

\section{Lempel-Ziv Compression}
Abraham Lempel and Jacob Ziv published papers for two lossless compression
algorithms, LZ77 and LZ78, published in 1977 and 1978, respectively. The core
idea behind both of these compression algorithms is to represent repeated
patterns in data with using pairs which are each comprised of a code and a
symbol. A code is an unsigned 16-bit integer and a symbol is a 8-bit ASCII
character.

We will explain this algorithm by working through an example.
Assume we have some string ``$abab$''. Assume we also have a
dictionary where the key is a \texttt{prefix}, also known as a word, and the value is a
code that we can utilize for fast look-ups. Since codes are 16-bit unsigned
integers, the dictionary is limited to $2^{16} - 1$ possible codes.
Why don't we have $2^{16}$ codes? Because we will be reserving a code to be used
as a stop code which indicates the end of our encoded data. We will define the
maximal usable code as \texttt{MAX\_CODE}, which has the value $2^{16} - 1$. The
dictionary is initialized with the empty word, or a string of zero length, at
the index \texttt{EMPTY\_CODE}, which is a macro for 1. We will specify the
first index in which a new word can be added to as the macro
\texttt{START\_CODE}, which has the value 2.

We now consider the first character: `$a$'. Since this is the first character,
we know that the string of all previously seen characters up to this point must
be the empty word; we haven't considered any characters prior to this point.  We
then append the current character `$a$' to the empty word, which yields the word
``$a$''. We check the dictionary in vain to see if we've encountered this word
before. Since we haven't yet seen this word, we will add this first word to the
dictionary and assign it the first available code of 2, or \texttt{START\_CODE}.
We set our previously seen word to be the empty word and output the pair
(\texttt{EMPTY\_CODE},\;`$a$').

We continue on, now considering the second character: `$b$'. We append this
character to our previously seen word, which yields ``$b$'' as our current word.
We again check the dictionary in vain to see if we've encountered this word
before. Since we haven't, we add this word to the dictionary and assign it the
next available code of 3. We set the previously seen word to the empty word and
output the pair (\texttt{EMPTY\_CODE},\;`$b$').

The next character we see is `$a$'. We append this character to our previously
seen word, which yields ``$a$'' as our current word. We check the dictionary to
see if we've encountered this word before. Indeed we have. We set the previously
seen word to ``$a$'' and proceed to the next character without any further
output.

We read in the last character, `$b$'. We append this character to our previously
seen word, which yields ``$ab$''. Clearly, this word isn't in the dictionary, so
pair comprised of the current symbol, `$b$', and the code of the previously
we add it and assign it the next available code of 4. What should we output? The
seen word. Since our previously seen word at this stage was ``$a$'', this code
will be 2. Thus, we output (2,\;`$b$'). To finish off compression, we output the
final pair (\texttt{STOP\_CODE},\;0). As you can imagine, this pair signals the
end of compressed data. The symbol in this final pair isn't used and the value
is of no significance. The macro \texttt{STOP\_CODE} has the value of 0.

Of course, a compression algorithm is useless without a corresponding
decompression algorithm. Assume we're reading in the output from the preceding
compression example. The output was comprised of the following pairs, in order:
(\texttt{EMPTY\_CODE},\;`$a$'), (\texttt{EMPTY\_CODE},\;`$b$'), (2,\;`$b$'),
(\texttt{STOP\_CODE},\,0). Similar to the compression algorithm, the
decompression algorithm initializes a dictionary containing only the empty word.
The catch is that the key and value for the decompressing dictionary is swapped;
each key is instead a code and each value a word. As you might imagine, the
decompression algorithm is the inverse of the compression algorithm, and thus
from the output pairs, the decompression algorithm will recreate the same
dictionary used during compression to output the decompressed data.

We consider the first pair: (\texttt{EMPTY\_CODE},\;`$a$'). We append the symbol
`$a$' to the word denoted by \texttt{EMPTY\_CODE}, which is the empty word.
Thus, the current word is ``$a$''. We add this word to the dictionary and assign
it the next available code of 2, then output the current word ``$a$''.

We consider the next pair: (\texttt{EMPTY\_CODE},\;`$b$'). We append the symbol
`$b$' to the word denoted by \texttt{EMPTY\_CODE}, which is the empty word.
Thus, the current word is ``$b$''. We add this word to the dictionary and assign
it the next available code of 3, then output the current word ``$b$''.

We now consider the next pair: (2,\;`$b$'). We append the symbol `$b$' to the
word denoted by the code 2, which we previously added to our dictionary. The
word denoted by this code is ``$a$'', whence we obtain our current word of
``$ab$''. We add this word to the dictionary and assign it the next available
code of 4, then output the current word ``$ab$''. Finally, we read in the last
pair: (\texttt{STOP\_CODE},\;0). Since the code is \texttt{STOP\_CODE}, we know
that we have finished decompression.

\begin{table}
    \caption{\textbf{Compression Example}}
    \begin{tabular}{ccc}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Initialized dictionary}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Word} & \textbf{Code} \\
                \hline
                ``'' & \texttt{EMPTY\_CODE} \\
                \hline
                     & \texttt{START\_CODE} \\
                \hline
                & 3 \\
                \hline
                & 4 \\
                \hline
                & $\ldots$ \\
                \hline
                & \texttt{MAX\_CODE} \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``a''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Word} & \textbf{Code} \\
                \hline
                ``'' & \texttt{EMPTY\_CODE} \\
                \hline
                ``$a$'' & \texttt{START\_CODE} \\
                \hline
                & 3 \\
                \hline
                & 4 \\
                \hline
                & $\ldots$ \\
                \hline
                & \texttt{MAX\_CODE} \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``b''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Word} & \textbf{Code} \\
                \hline
                ``'' & \texttt{EMPTY\_CODE} \\
                \hline
                ``$a$'' & \texttt{START\_CODE} \\
                \hline
                ``$b$'' & 3 \\
                \hline
                & 4 \\
                \hline
                & $\ldots$ \\
                \hline
                & \texttt{MAX\_CODE} \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``ab''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Word} & \textbf{Code} \\
                \hline
                ``'' & \texttt{EMPTY\_CODE} \\
                \hline
                ``$a$'' & \texttt{START\_CODE} \\
                \hline
                ``$b$'' & 3 \\
                \hline
                ``$ab$'' & 4 \\
                \hline
                & $\ldots$ \\
                \hline
                & \texttt{MAX\_CODE} \\
           \end{tabular}
        \end{minipage}
    \end{tabular}
\end{table}

\begin{table}
    \caption{\textbf{Decompression Example}}
    \begin{tabular}{ccc}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Initialized dictionary}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Code} & \textbf{Word} \\
                \hline
                \texttt{EMPTY\_CODE} & ``'' \\
                \hline
                \texttt{START\_CODE} & \\
                \hline
                3 & \\
                \hline
                4 & \\
                \hline
                $\ldots$ & \\
                \hline
                \texttt{MAX\_CODE} & \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``a''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Code} & \textbf{Word} \\
                \hline
                \texttt{EMPTY\_CODE} & ``'' \\
                \hline
                \texttt{START\_CODE} & ``$a$'' \\
                \hline
                3 & \\
                \hline
                4 & \\
                \hline
                $\ldots$ & \\
                \hline
                \texttt{MAX\_CODE} & \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``b''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Code} & \textbf{Word} \\
                \hline
                \texttt{EMPTY\_CODE} & ``'' \\
                \hline
                \texttt{START\_CODE} & ``$a$'' \\
                \hline
                3 & ``$b$'' \\
                \hline
                4 & \\
                \hline
                $\ldots$ & \\
                \hline
                \texttt{MAX\_CODE} & \\
           \end{tabular}
           \label{ahaha}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``ab''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Code} & \textbf{Word} \\
                \hline
                \texttt{EMPTY\_CODE} & ``'' \\
                \hline
                \texttt{START\_CODE} & ``$a$'' \\
                \hline
                3 & ``$b$'' \\
                \hline
                4 & ``$ab$'' \\
                \hline
                $\ldots$ & \\
                \hline
                \texttt{MAX\_CODE} & \\
           \end{tabular}
        \end{minipage}
    \end{tabular}
\end{table}


If the basic idea behind the compression and decompression algorithms do not
immediately make sense to you, or if you desire a more visual representation of
how the algorithms work, make sure to attend section and get help early!
\textcolor{red}{Things will not get easier as time goes on.}

\section{Your Task}

Your task is to implement two programs called \texttt{encode} and
\texttt{decode} which perform LZ78 compression and decompression, respectively.
The requirements for your programs are as follows:

\begin{enumerate}
    \item \texttt{encode} can compress any file, text or binary.

    \item \texttt{decode} can decompress any file, text or binary, that was
        compressed with \texttt{encode}.

    \item Both operate on both little and big endian systems.
        \emph{Interoperability is required}.

    \item Both use variable bit-length codes.

    \item Both perform read and writes in efficient blocks of 4KB.

    \item Both \texttt{encode} and \texttt{decode} must interoperate
        with the provided binaries -- not just your code.
\end{enumerate}

\section{Specifics}

You will need to implement some new ADTs for this assignment: an ADT for tries
and an ADT for words. In addition to these new ADTS, you will need to
be concerned about variable-length codes, I/O, and endianness.

\subsection{Tries}
The most costly part of compression is checking for existing prefixes, or words.
You could utilize a hash table, or just an array to store words, but that
wouldn't be optimal, as many of the words you need to store are prefixes of
other words. Instead you choose to utilize a \emph{trie}.

A trie\footnote{Edward Fredkin, ``{T}rie memory.'' \emph{Communications of the
ACM} 3, no. 9 (1960): 490--499.} is an efficient information re-\emph{trie}-val
data structure, commonly known as a prefix tree. Each node in a trie represents
a symbol, or a character, and contains $n$ child nodes, where $n$ is the size of
the alphabet you are using. In most cases, the alphabet used is the set of ASCII
characters, so $n = 256$. You will use a trie during compression to store words.

\begin{center}
    \tikzset{
        sibling distance=1.2cm, level distance=0.8cm,
        split/.style={
            draw, rectangle split, rectangle split parts=2,draw,inner
            sep=0pt,rectangle split horizontal,minimum size=0ex,text
            width=1ex,align=center,rectangle split part align=base
        },
        boxed/.style={draw,minimum size=3ex,inner sep=0pt,align=center},
        edge from parent/.style={draw, edge from parent path={[->,thick]
        (\tikzparentnode)  -- ($(\tikzchildnode.north) + 2*(0pt,1pt)$) }}
    }

    \begin{tikzpicture}
        \Tree
        [.\node[boxed] (S1) {\nodepart{one}\texttt{ ROOT }};
            [.\node[boxed] (L1) {\nodepart{one}b};
                [.\node[boxed] (L2) {y}; ]
            ]
            [.\node[boxed] (M1) {\nodepart{one}s};
                [.\node[boxed] (L3) {e};
                    [.\node[boxed] (L4) {a};]
                    [.\node[boxed] (R4) {l};
                        [.\node[boxed] (M2) {l};
                            [.\node[boxed] (M3) {s}; ]
                        ]
                    ]
                ]
                [.\node[boxed] (R3) {h};
                    [.\node[boxed] (L5) {e};
                        [.\node[boxed] (M4) {l};
                            [.\node[boxed] (M5) {l};
                                [.\node[boxed] (M6) {s}; ]
                            ]
                        ]
                    ]
                    [.\node[boxed] (R5) {o};
                        [.\node[boxed] (M7) {r};
                            [.\node[boxed] (M8) {e};]
                        ]
                    ]
                ]
            ]
            [.\node[boxed] (R1) {\nodepart{one}t};
                [.\node[boxed] (R2) {h};
                    [.\node[boxed] (M9) {e}; ]
                ]
            ]
        ]
    \end{tikzpicture}
\end{center}

Above is an example of a trie containing the following words: ``$She$'',
``$sells$'', ``$sea$'', ``$shells$'', ``$by$'', ``$the$'', ``$sea$'',
``$shore$''. Searching for a word in the trie means stepping down for each
symbol in the word, starting from the root. Stepping down the trie is simply
checking if the current node we have traversed to has a child node representing
the symbol we are looking for, and setting the current node to be the child node
if it does exist. Thus, to find ``$sea$'', we would start from the trie's root
and step down to `$s$', then `$e$', then `$a$'.  If any symbol is missing, or
the end of the trie is reached without fully matching a word, while stepping
through the trie, then the word is not in the trie.  You \emph{must} follow the
specification shown below when implementing your trie ADT.

\subsubsection{\texttt{TrieNode}}

\begin{codelisting}{}
struct TrieNode {
    TrieNode *children[ALPHABET];
    uint16_t code;
};
\end{codelisting}

The \texttt{TrieNode struct} will have the two fields shown above. Each trie
node has an array of 256 pointers to trie nodes as children, one for
each ASCII character. It should be easy to see how this simplifies
searching for the next character in a word in the trie. The
\texttt{code} field stores the 16-bit code for the word that ends with
the trie node containing the code. This means that the code for some
word ``$abc$'' would be contained in the trie node for `$c$'.  Note that
there isn't a field that indicates what character a trie node
represents. This is because the trie node's index in its parent's array
of child nodes indicates what character it represents. The
\texttt{trie\_step()} function will be repeatedly called to check if a
word exists in the trie. A word only exists if the trie node returned by
the last step corresponding to the last character in the word isn't
\texttt{NULL}.

\subsubsection{\texttt{TrieNode *trie\_node\_create(uint16\_t code)}}
Constructor for a \texttt{TrieNode}. The node's code is set to
\texttt{code}. Make sure each of the children node pointers are
\texttt{NULL}.

\subsubsection{\texttt{void trie\_node\_delete(TrieNode *n)}}
Destructor for a \texttt{TrieNode}. Note that only a \emph{single}
pointer is passed here. The destructors you have written in the past
have taken double pointers in order to \texttt{NULL} the pointer by
dereferencing it. For this assignment, a single pointer is much
more manageable and simplifies the code you have to otherwise write.

\subsubsection{\texttt{TrieNode *trie\_create(void)}}
Initializes a trie: a root \texttt{TrieNode} with the code
\texttt{EMPTY\_CODE}. Returns the root, a \texttt{TrieNode *}, if
successful, \texttt{NULL} otherwise.

\subsubsection{\texttt{void trie\_reset(TrieNode *root)}}
Resets a trie to just the root \texttt{TrieNode}. Since we are working
with finite codes, eventually we will arrive at the end of the available
codes (\texttt{MAX\_CODE}).  At that point, we must reset the trie by
deleting its children so that we can continue compressing/decompressing
the file. Make sure that each of the root's children nodes are
\texttt{NULL}.

\subsubsection{\texttt{void trie\_delete(TrieNode *n)}}
Deletes a sub-trie starting from the trie rooted at node \texttt{n}.
This will require recursive calls on each of \texttt{n}'s children.
Make sure to set the pointer to the children nodes to \texttt{NULL}
after you free them with \texttt{trie\_node\_delete()}.

\subsubsection{\texttt{TrieNode *trie\_step(TrieNode *n, uint8\_t sym)}}
Returns a pointer to the child node reprsenting the symbol sym.
If the symbol doesn't exist, \texttt{NULL} is returned.

\subsection{Word Tables}

Although compression can be performed using a trie, decompression still
needs to use a look-up table for quick code to word translation. This
look-up table will be defined as a new \texttt{struct} called a
\texttt{WordTable}. Since we can only have $2^{16}-1$ codes, one of
which is reserved as a stop code, we can use a fixed word table size of
\texttt{UINT16\_MAX}, where \texttt{UINT16\_MAX} is a macro defined in
\texttt{inttypes.h} as the maximum value of a unsigned 16-bit integer.
Hint: this has the exact same value as \texttt{MAX\_CODE}, which we
defined earlier.

Why aren't we using hash tables to store words? Because there is a
\emph{fixed} number of codes. Each index of this word table will be a
new \texttt{struct} called a \texttt{Word}. You will store words in byte
arrays, or arrays of \texttt{uint8\_t}. This is because strings in
\textbf{C} are null-terminated, and problems with compression occur if a
binary file is being compressed and contains null characters that are
placed into strings.  Since we need to know how long a word is, a
\texttt{Word} will also have a field for storing the length of the byte
array, since we can't use \texttt{string.h} functions like
\texttt{strlen()} on byte arrays. You \emph {must} use the following
specification for the new \texttt{Word} ADT.

\subsubsection{\texttt{Word}}
\begin{codelisting}{}
struct Word {
    uint8_t *syms;
    uint32_t len;
};
\end{codelisting}
A \texttt{Word} holds an array of symbols, \texttt{syms}, stored as bytes
in an array. The length of the array storing the symbols a \texttt{Word}
represents is stored in \texttt{len}.

\subsubsection{\texttt{WordTable}}
\begin{codelisting}{}
typedef Word * WordTable
\end{codelisting}

To make things easier to reason about, we can define an array of \texttt{Words}
as a \texttt{WordTable}.

\subsubsection{\texttt{Word *word\_create(uint8\_t *syms, uint32\_t len)}}
Constructor for a word where \texttt{sysms} is the array of symbols
a \texttt{Word} represents. The length of the array of symbols
is given by \texttt{len}. This function returns a \texttt{Word *}
if successful or \texttt{NULL} otherwise.

\subsubsection{\texttt{Word *word\_append\_sym(Word *w, uint8\_t sym)}}
Constructs a new \texttt{Word} from the specified \texttt{Word}, \texttt{w},
appended with a symbol, \texttt{sym}.
The \texttt{Word} specified to append to may be empty.
If the above is the case, the new \texttt{Word} should contain only the symbol.
Returns the new \texttt{Word} which represents the result of appending.

\subsubsection{\texttt{void word\_delete(Word *w)}}
Destructor for a \texttt{Word}, \texttt{w}. Like with
\texttt{trie\_node\_create()} in \S 4.1.3, a single pointer is used
here to reduce the complexity of memory management, thus reducing the
chances of having memory-related errors.

\subsubsection{\texttt{WordTable *wt\_create(void)}}
Creates a new \texttt{WordTable}, which is an array of Words.  A
\texttt{WordTable} has a pre-defined size of \texttt{MAX\_CODE}, which
has the value \texttt{UINT16\_MAX}. This is because codes are 16-bit
integers.  A \texttt{WordTable} is initialized with a single Word at
index \texttt{EMPTY\_CODE}. This \texttt{Word} represents the empty
word, a string of length of zero.

\subsubsection{\texttt{void wt\_reset(WordTable *wt)}}
Resets a \texttt{WordTable}, \texttt{wt}, to contain just the empty
Word. Make sure all the other words in the table are \texttt{NULL}.

\subsection{Codes}

It is a requirement that your programs, \texttt{encode} and \texttt{decode},
be able to read and write pairs containing variable bit-length codes. As an
example, assume we are going to write the pair (13,\;`$a$'). What is the minimum
number of bits needed to represent 13? We can easily calculate the minimum
number of bits needed to represent any integer $x \geq 1$ using the formula
$\lfloor \log_2 (x) \rfloor + 1$. The only edge case is with 0, whose bit-length
is 1. Thus, we calculate that the minimum number of bits needed to represent 13,
or the bit-length of 13, to be 4. That being said, in practice, the bit-length of
the code in the pair you're going output wouldn't be the bit-length of the code
itself, but rather the bit-length of the \emph{next available code} assignable, as
described in the earlier compression example. The reason for this is because
decompression \emph{must} know at all times the bit-length of the code it is going
to read. Because the dictionary constructed by decompression contains exactly
the words and codes contained by the trie constructed by compression, it is
evident that, by using the bit-length of the next available code, that compression
and decompression will agree on the variable bit-lengths of codes. Note that only
codes have variable bit-lengths: symbols in a pair are always 8 bits.

As an example, assume we are going to output the pair (13,\;`$a$'), and the next
available code assignable in our dictionary is 64. We will need to convert this
pair to binary, starting with the code. As stated earlier, the bit-length of the
code is the bit-length of the next available code. We calculate that the bit-length
of 64 is 7. We start from the least significant bit of our code, 13, and
construct the code portion of the pair's binary representation:
\texttt{LSB 1011000 MSB}. Note that the LSB is on the left and the MSB
is on the right. Zeroes are padded because the bit-length of 64 is 7,
while the bit-length of 13 is 4, which is why there are three padded
zeroes.  In the same fashion, we start from the least significant bit of
our symbol, `$a$', and add the symbol portion of the pair's binary
representation to the previous code portion, which yields \texttt{LSB
101100010000110 MSB}, since the ASCII value of `$a$' is 97.

Now assume that we are reading in the binary \texttt{LSB 101100010000110
MSB} and converting that back into a pair. We know that the next
available code assignable by compression and decompression are the same
at every step. Thus, we know that compression must have output the
pair's code with the bit-length of 64, which is 7. We go through the
first 7 bits of the binary: \texttt{1}, \texttt{0}, \texttt{1},
\texttt{1}, \texttt{0}, \texttt{0}, and \texttt{0}, summing up the bits
as we go, simulating how positional numbering systems work.  This means
we perform $1 \cdot 2^0 + 0 \cdot 2^1 + 1 \cdot 2^2 + 1 \cdot 2^3 + 0
\cdot 2^4 + 0 \cdot 2^5 + 0 \cdot 2^6 = 13$, exactly the code output by
compression. We do the same for the remaining 8 bits to reconstruct the
symbol.

\begin{codelisting}{code.h}
#ifndef __CODE_H__
#define __CODE_H__

#include <inttypes.h>

#define STOP_CODE   0         // Signals end of decoding/decoding.
#define EMPTY_CODE  1             // Code denoting the empty Word.
#define START_CODE  2             // Starting code of new Words.
#define MAX_CODE    UINT16_MAX    // Maximum code.

#endif
\end{codelisting}

\subsection{I/O}

It is also a requirement that your programs, \texttt{encode} and
\texttt{decode}, perform efficient I/O. Reads and writes will be done 4KB, or a
block, at a time, which implicitly requires that you buffer I/O. Buffering is
the act of storing data into a buffer, which you can think of as an array of
bytes. You will be implementing an I/O module for this assignment, and its
API is explained in the following sections.

\subsubsection{\texttt{FileHeader}}

\begin{codelisting}{}
struct FileHeader {
    uint32_t magic;
    uint16_t protection;
};
\end{codelisting}

This is the \texttt{struct} definition for the file header, which
contains the magic number for your program and the protection bit mask
for the original file.  The file header is the first thing that appears
in a compressed file. The magic number field, \texttt{magic}, serves as
a unique identifier for files compressed by \texttt{encode}.
\texttt{decode} should only be able to decompress files which have the
correct magic number. This magic number is \texttt{0xBAADBAAC}.

Before writing the file header to the compressed file using
\texttt{write\_header()}, you must swap the endianness of the fields if
necessary since \emph{interoperability is required}. If your program is
run on a system using big endian, the fields must be swapped to little
endian, since little endian is canonical. A module specifically for
handling endianness will be provided.

\subsubsection{\texttt{int read\_bytes(int infile, uint8\_t *buf, int
to\_read)}}

This will be a useful helper function to perform reads. As you may know,
the \texttt{read()} syscall \emph{does not} always guarantee that it
will read all the bytes specified. For example, a call could be issued
to read a block of bytes, but it might only read half a block. So, we
write a wrapper function to \emph{loop calls} to \texttt{read()} until
we have either read all the bytes that were specified
(\texttt{to\_read}), or there are no more bytes to read. The number of
bytes that were read are returned. \textcolor{red}{You should use this
function whenever you need to perform a read.}

\subsubsection{\texttt{int write\_bytes(int outfile, uint8\_t *buf, int
to\_write)}}

This function is very much the same as \texttt{read\_bytes()}, except
that it is for looping calls to \texttt{write()}. As you may imagine,
\texttt{write()} isn't guaranteed to write out all the specified bytes
(\texttt{to\_write}), and so we loop until we have either written out
all the bytes specified, or no bytes were written. The number of bytes
written out is returned.  \textcolor{red}{You should use this function
whenever you need to perform a write.}


\subsubsection{\texttt{void read\_header(int infile, FileHeader *header)}}
This reads in \texttt{sizeof(FileHeader)} bytes from the input file.
These bytes are read into the supplied header. Endianness is swapped if
byte order isn't little endian. Along with reading the header, it must
verify the magic number.

\subsubsection{\texttt{void write\_header(int outfile, FileHeader *header)}}
Writes \texttt{sizeof(FileHeader)} bytes to the output file. These
bytes are from the supplied header. Endianness is swapped if byte order
isn't little endian.

\subsubsection{\texttt{bool read\_sym(int infile, uint8\_t *sym)}}
An index  keeps  track of the  currently  read  symbol  in the  buffer.
Once  all  symbols  are  processed , another  block is read. If less
than a block is read , the end of the  buffer  is  updated.  Returns
true if there  are  symbols  to be read , false  otherwise.

\subsubsection{\texttt{void write\_pair(int outfile, uint16\_t code,
uint8\_t sym, int bitlen)}}
``Writes'' a pair to \texttt{outfile}. In reality, the pair is buffered.
A pair is comprised of a code and a symbol.  The bits of the code are
buffered first, starting from the LSB.  The bits of the symbol are
buffered next, also starting from the LSB.  The code buffered has a
bit-length of bitlen. The buffer is written out whenever it is filled.

\subsubsection{\texttt{void flush\_pairs(int outfile)}}
Writes out any remaining pairs of symbols and codes to the output file.

\subsubsection{\texttt{bool read\_pair(int infile, uint16\_t *code,
uint8\_t *sym, int bitlen)}}
``Reads'' a pair (code and symbol) from the input file.
The ``read'' code is placed in the pointer to code (e.g. *code = val)
The ``read'' symbol is placed in the pointer to sym (e.g. *sym = val).
In reality, a block of pairs is read into a buffer.  An index keeps
track of the current bit in the buffer.  Once all bits have been
processed, another block is read.  The first \texttt{bitlen} bits are
the code, starting from the LSB.  The last 8 bits of the pair are the
symbol, starting from the LSB.  Returns true if there are pairs left to
read in the buffer, else false.  There are pairs left to read if the
read code is not \texttt{STOP\_CODE}.

\subsubsection{\texttt{void write\_word(int outfile, Word *w)}}
``Writes'' a pair to the output file. Each symbol of the Word is placed
into a buffer. The buffer is written out when it is filled.

\subsubsection{\texttt{void flush\_words(int outfile)}}
Writes out any remaining symbols in the buffer to the outfile.

Note that the output file in which you write to must have the same
protection bits as the original file. Like in assignment 4, you will
make use of \texttt{fstat()} and \texttt{fchmod()}.

All reads and writes in this program must be done using the system calls
\texttt{read()} and \texttt{write()}, which means that you must use the
system calls \texttt{open()} and \texttt{close()} to get your file
descriptors. As stated earlier, all reads and writes must be performed
in efficient blocks of 4KB. \textcolor{red}{You will want to use two
static 4KB uint8\_t arrays to serve as buffers: one to store binary
pairs and the other to store characters.} Each of these buffers should
have an index, or a variable, to keep track of the current byte or bit
that has been processed.

\section{Program Options}

Your \texttt{encode} program must support the following \texttt{getopt()}
options:

\begin{itemize}
    \item \texttt{-v} : Print compression statistics to \texttt{stderr}.

    \item \texttt{-i <input>} : Specify input to compress (\texttt{stdin} by
        default)

    \item \texttt{-o <output>} : Specify output of compressed input
        (\texttt{stdout} by default)
\end{itemize}

Your \texttt{decode} program must support the following \texttt{getopt()}
options:

\begin{itemize}
    \item \texttt{-v} : Print decompression statistics to
      \texttt{stderr}.

    \item \texttt{-i <input>} : Specify input to decompress (\texttt{stdin} by
        default)

    \item \texttt{-o <output>} : Specify output of decompressed input
        (\texttt{stdout} by default)
\end{itemize}

The verbose option enables a flag to print out informative statistics about the
compression or decompression that is performed. These statistics include the
compressed file size, the uncompressed file size, and \emph{space
saving}.
The formula for calculating space saving is:
\[
  100\times\left ( 1-\frac{\text{compressed size}} {\text{uncompressed size}} \right).
\]
The verbose output of both \texttt{encode} and
\texttt{decode} must match the following:

\begin{verbatim}
Compressed file size: X bytes
Uncompressed file size: X bytes
Space saving: XX.XX%
\end{verbatim}

\section{Compression}
The following steps for compression will refer to the input file descriptor to
compress as \texttt{infile} and the compressed output file descriptor as
\texttt{outfile}.

\begin{enumerate}
    \item Open \texttt{infile} with \texttt{open()}. If an error occurs,
      print a helpful message and exit with a status code indicating
      that an error occurred. \texttt{infile} should be \texttt{stdin}
      if an input file wasn't specified.

    \item The first thing in \texttt{outfile} must be the file header,
      as defined in the file \texttt{io.h}. The magic number in the
      header must be \texttt{0xBAADBAAC}. The file size and the
      protection bit mask you will obtain using \texttt{fstat()}. See
      the man page on it for details.

    \item Open \texttt{outfile} using \texttt{open()}. The permissions
      for \texttt{outfile} should match the protection bits as set in
      your file header. Any errors with opening \texttt{outfile} should
      be handled like with \texttt{infile}. \texttt{outfile} should be
      \texttt{stdout} if an output file wasn't specified.

    \item Write the filled out file header to \texttt{outfile} using
        \texttt{write\_header()}. This means writing out the \texttt{struct}
        itself to the file, as described in the comment block of the function.

    \item Create a trie. The trie initially has no children and consists
      solely of the root. The code stored by this root trie node should
      be \texttt{EMPTY\_CODE} to denote the empty word. You will need to
      make a copy of the root node and use the copy to step through the
      trie to check for existing prefixes. This root node copy will be
      referred to as \texttt{curr\_node}. The reason a copy is needed is
      that you will eventually need to reset whatever trie node you've
      stepped to back to the top of the trie, so using a copy lets you
      use the root node as a base to return to.

    \item You will need a monotonic counter to keep track of the next
      available code. This counter should start at \texttt{START\_CODE},
      as defined in the supplied \texttt{code.h} file. The counter
      should be a \texttt{uint16\_t} since the codes used are unsigned
      16-bit integers.  This will be referred to as \texttt{next\_code}.

    \item You will also need two variables to keep track of the previous
      trie node and previously read symbol. We will refer to these as
      \texttt{prev\_node} and \texttt{prev\_sym}, respectively.

    \item Use \texttt{read\_sym()} in a loop to read in all the symbols
      from \texttt{infile}. Your loop should break when
      \texttt{read\_sym()} returns false. For each symbol read in, call
      it \texttt{curr\_sym}, perform the following:

        \begin{enumerate}
            \item Set \texttt{next\_node} to be \texttt{trie\_step(curr\_node,
                curr\_sym)}, stepping down from the current node to the
                currently read symbol.

            \item If \texttt{next\_node} is not \texttt{NULL}, that means we
                have seen the current prefix. Set \texttt{prev\_node} to be
                \texttt{curr\_node} and then \texttt{curr\_node} to be
                \texttt{next\_node}.

            \item Else, since \texttt{next\_node} is \texttt{NULL}, we know we
                have not encountered the current prefix. We write the pair
                (\texttt{curr\_node->code}, \texttt{curr\_sym}), where the
                bit-length of the written code is the bit-length of
                \texttt{next\_code}. We now add the current prefix to the trie.
                Let \texttt{curr\_node->children[curr\_sym]} be a new trie node
                whose code is \texttt{next\_code}. Reset \texttt{curr\_node} to
                point at the root of the trie and increment the value of
                \texttt{next\_code}.

            \item Check if \texttt{next\_code} is equal to \texttt{MAX\_CODE}.
                If it is, use \texttt{trie\_reset()} to reset the trie to just
                having the root node. This reset is necessary since we have a
                finite number of codes.

            \item Update \texttt{prev\_sym} to be \texttt{curr\_sym}.
        \end{enumerate}

    \item After processing all the characters in \texttt{infile}, check
      if \texttt{curr\_node} points to the root trie node. If it does
      not, it means we were still matching a prefix. Write the pair
      (\texttt{prev\_node->code}, \texttt{prev\_sym}). The bit-length of
      the code written should be the bit-length of \texttt{next\_code}.
      Make sure to increment \texttt{next\_code} and that it stays
      within the limit of \texttt{MAX\_CODE}. Hint: use the modulo
      operator.

    \item Write the pair (\texttt{STOP\_CODE}, 0) to signal the end of
      compressed output. Again, the bit-length of code written should be
      the bit-length of \texttt{next\_code}.

    \item Make sure to use \texttt{flush\_pairs()} to flush any unwritten,
      buffered pairs. Remember, calls to \texttt{write\_pair()} end up
      buffering them under the hood. So, we have to remember to flush
      the contents of our buffer.

    \item Use \texttt{close()} to close \texttt{infile} and \texttt{outfile}.
\end{enumerate}

\section{Decompression}

The following steps for decompression will refer to the input file to decompress
as \texttt{infile} and the uncompressed output file as \texttt{outfile}.

\begin{enumerate}
    \item Open \texttt{infile} with \texttt{open()}. If an error occurs, print a
        helpful message and exit with a status code indicating that an error
        occurred. \texttt{infile} should be \texttt{stdin} if an input file
        wasn't specified.

    \item Read in the file header with \texttt{read\_header()}, which also
        verifies the magic number. If the magic number is verified then
        decompression is good to go and you now have a header which contains the
        original protection bit mask.

    \item Open \texttt{outfile} using \texttt{open()}. The permissions for
        \texttt{outfile} should match the protection bits as set in your file
        header that you just read. Any errors with opening \texttt{outfile}
        should be handled like with \texttt{infile}. \texttt{outfile} should be
        \texttt{stdout} if an output file wasn't specified.

    \item Create a new word table with \texttt{wt\_create()} and make sure each
        of its entries are set to \texttt{NULL}. Initialize the table to have
        just the empty word, a word of length 0, at the index
        \texttt{EMPTY\_CODE}. We will refer to this table as \texttt{table}.

    \item You will need two \texttt{uint16\_t} to keep track of the
        current code and next code. These will be referred to as
        \texttt{curr\_code} and \texttt{next\_code}, respectively.
        \texttt{next\_code} should be initialized as \texttt{START\_CODE} and
        functions exactly the same as the monotonic counter used during
        compression, which was also called \texttt{next\_code}.

    \item Use \texttt{read\_pair()} in a loop to read all the pairs from
        \texttt{infile}. We will refer to the code and symbol from each read
        pair as \texttt{curr\_code} and \texttt{curr\_sym}, respectively. The
        bit-length of the code to read is the bit-length of \texttt{next\_code}. The
        loop breaks when the code read is \texttt{STOP\_CODE}. For each read
        pair, perform the following:

        \begin{enumerate}
            \item As seen in the decompression example, we will need to append
                the read symbol with the word denoted by the read code and add
                the result to \texttt{table} at the index \texttt{next\_code}.
                The word denoted by the read code is stored in
                \texttt{table[curr\_code]}. We will append
                \texttt{table[curr\_code]} and \texttt{curr\_sym} using
                \texttt{word\_append\_sym()}.

            \item Write the word that we just constructed and added to the
                table with \texttt{write\_word()}. This word should have been
                stored in \texttt{table[next\_code]}.

            \item Increment \texttt{next\_code} and check if it equals
                \texttt{MAX\_CODE}. If it has, reset the table using
                \texttt{wt\_reset()} and set \texttt{next\_code} to be
                \texttt{START\_CODE}. This mimics the resetting of the trie
                during compression.
        \end{enumerate}

    \item Flush any buffered words using \texttt{flush\_words()}. Like
      with \texttt{write\_pair()}, \texttt{write\_word()} buffers words
      under the hood, so we have to remember to flush the contents of
      our buffer.

    \item Close \texttt{infile} and \texttt{outfile} with \texttt{close()}.
\end{enumerate}

\section{Deliverables}
You will need to turn in:

\begin{enumerate}
    \item \texttt{Makefile}:
        \begin{itemize}
            \item \texttt{CFLAGS=-Wall -Wextra -Werror -Wpedantic} must
                be included.

            \item \texttt{CC=clang} must be specified.

            \item \texttt{make clean} must remove all files that are compiler
                generated.

            \item \texttt{make encode} should build your \texttt{encode}
                program.

            \item \texttt{make decode} should build your \texttt{decode}
                program.

            \item \texttt{make} should build both \texttt{encode} and
                \texttt{decode}, as should \texttt{make all}.

            \item Your programs should have no memory leaks.
        \end{itemize}

    \item Your programs \emph{must} have the following source and header files:
        \begin{itemize}
            \item \texttt{encode.c} : contains the \texttt{main()} function for
                the \texttt{encode} program.

            \item \texttt{decode.c} : contains the \texttt{main()} function for
                the \texttt{decode} program.

            \item \texttt{trie.c}: the source file for the Trie ADT.

            \item \texttt{trie.h}: the header file for the Trie ADT.
                \textcolor{red}{You \emph{must} not modify this file.}

            \item \texttt{word.c}: the source file for the Word ADT.

            \item \texttt{word.h}: the header file for the Word ADT.
                \textcolor{red}{You \emph{must} not modify this file.}

            \item \texttt{io.c}: the source file for the I/O module.

            \item \texttt{io.h}: the header file for the I/O module.
                \textcolor{red}{You \emph{must} not modify this file.}

            \item \texttt{endian.h}: the header file for the endianness module.
                \textcolor{red}{You \emph{must} not modify this file.}

            \item \texttt{code.h}: the header file containing macros for
              reserved codes. \textcolor{red}{You \emph{must} not modify
              this file.}
        \end{itemize}

    \item You may have other source and header files, but
        \emph{do not try to be overly clever}.

    \item Running \texttt{scan-build} yields no bugs. If there are any
      false positives, make sure to explain why they are false positives
      in your \texttt{README.md}.

    \item \texttt{README.md}: This must be in Markdown. This should
      describe how to use your program and Makefile. This also contains
      any explanations for complaints generated by \texttt{scan-build}.

    \item \texttt{DESIGN.pdf}: This must be a PDF. The design document should
        describe your design for your program with enough detail that a
        sufficiently knowledgeable programmer would be able to replicate your
        implementation. This does not mean copying your entire program in
        verbatim. You should instead describe how your program works with
        supporting pseudo-code.

    \item Working \texttt{encode} and \texttt{decode} programs, along with test
        files, and other source files will be supplied in the resources repository.
\end{enumerate}


\section{Submission}

To submit your assignment, refer back to \texttt{assignment0} for the steps on
how to submit your assignment through \texttt{git}. Remember:
\emph{add, commit,} and \emph{push}!

\textcolor{red}{Your assignment is turned in \emph{only} after you have pushed.
If you forget to push, you have not turned in your assignment and you will get
a \emph{zero}. ``I forgot to push'' is not a valid excuse. It is \emph{highly}
recommended to commit and push your changes \emph{often}.}

\appendix
\section{LZ78 Algorithm Pseudocode}

\subsection{Compression}

\begin{codebox}
    \Procname{\proc{Compress}(\id{infile}, \id{outfile})}
    \li \id{root} $\gets$ \proc{trie\_create}()
    \li \id{curr\_node} $\gets$ \id{root}
    \li \id{prev\_node} $\gets$ \const{null}
    \li \id{curr\_sym} $\gets$ 0
    \li \id{prev\_sym} $\gets$ 0
    \li \id{next\_code} $\gets$ \const{start\_code}
    \li \While \proc{read\_sym}(\id{infile}, \id{\&curr\_sym}) \kw{is} \const{true}
    \li \Then \id{next\_node} $\gets$ \proc{trie\_step}(\id{curr\_node},
              \id{curr\_sym})
              \li     \If \id{next\_node} \kw{is not} \const{null}
    \li     \Then \id{prev\_node} $\gets$ \id{curr\_node}
    \li           \id{curr\_node} $\gets$ \id{next\_node}
    \li     \Else
    \li           \proc{write\_pair}(\id{outfile},
                  \attrib{\id{curr\_node}}{code}, \id{curr\_sym},
                  \proc{bit-length}(\id{next\_code}))
    \li           \attrib{\id{curr\_node}}{children[curr\_sym]} $\gets$
                    \proc{trie\_node\_create}(\id{next\_code})
    \li           \id{curr\_node} $\gets$ \id{root}
    \li \id{next\_code} $\gets$ \id{next\_code} + 1
            \End
            \li     \If \id{next\_code} \kw{is} \const{max\_code}
    \li     \Then \proc{trie\_reset}(\id{root})
    \li           \id{curr\_node} $\gets$ \id{root}
    \li           \id{next\_code} $\gets$ \const{start\_code}
            \End
    \li     \id{prev\_sym} $\gets$ \id{curr\_sym}
        \End
        \li \If \id{curr\_node} \kw{is not} \id{root}
    \li \Then \proc{write\_pair}(\id{outfile},
    \attrib{\id{prev\_node}}{code}, \id{prev\_sym},
    \proc{bit-length}(\id{next\_code}))
    \li $\id{next\_code} \gets (\id{next\_code} + 1) \;\%\;\const{max\_code}$
        \End
        \li \proc{write\_pair}(\id{outfile}, \const{stop\_code}, 0,
        \proc{bit-length}(\id{next\_code}))
        \li \proc{flush\_pairs}(\id{outfile})
\end{codebox}

\subsection{Decompression}

\begin{codebox}
    \Procname{\proc{Decompress}(\id{infile}, \id{outfile})}
    \li \id{table} $\gets$ \proc{wt\_create}()
    \li \id{curr\_sym} $\gets$ 0
    \li \id{curr\_code} $\gets$ 0
    \li \id{next\_code} $\gets$ \const{start\_code}
    \li \While \proc{read\_pair}(\id{infile}, \id{\&curr\_code},
    \id{\&curr\_sym}, \proc{bit-length}(\id{next\_code})) \kw{is} \const{true}
    \li \Then
              \id{table}[\id{next\_code}] $\gets$
              \proc{word\_append\_sym}(\id{table}[\id{curr\_code}],
              \id{curr\_sym})
              \li \proc{write\_word}(\id{outfile},
              \id{table}[\id{next\_code}])
              \li \id{next\_code} $\gets$ \id{next\_code} + 1
        \li     \If \id{next\_code} \kw{is} \const{max\_code}
    \li     \Then \proc{wt\_reset}(\id{table})
    \li           \id{next\_code} $\gets$ \const{start\_code}
                \End
        \End
    \li \proc{flush\_words}(\id{outfile})
\end{codebox}

\end{document}
