\documentclass{article}
\usepackage{fullpage,fourier,amsmath,amssymb}
\usepackage{listings,color,url,hyperref}
\usepackage{mdframed}
\usepackage{clrscode3e}
\usepackage{parskip}
\usepackage{caption}
\captionsetup{labelformat=empty}
\usepackage[x11names]{xcolor}
\usepackage{forest}
\usepackage{tikz-qtree}
\usetikzlibrary{fit,backgrounds,shapes.multipart,calc,positioning}

\usepackage{epigraph}
\title{Assignment 7 \\ Lempel-Ziv Compression}
\author{Prof. Darrell Long \\
CSE 13S -- Winter 2020}
\date{Due: March 15\textsuperscript{th} at 11:59 pm}

\input{../lststyle}
\input{../footer}

\begin{document}\maketitle

\lstset{language=C, style=c99}

\epigraphwidth=0.65\textwidth
\epigraph{\emph{Everyday, we create 2.5 quintillion bytes of data -- so much
that 90\% of the data in the world today has been created in the last two years
alone.}}{---IBM report on Big Data (2011)}

\section{Introduction}
Compressing data means reducing the number of bits needed to represent it.
Compressed data, due to its reduced size, is a lot faster to transfer and less
expensive to store, freeing up storage and increasing network capacity.
Algorithms that perform data compression are known as data compression
algorithms. Data compression algorithms are divided into two categories: lossy
and lossless.  Lossy compression algorithms compress more than lossless
compression algorithms, but at the cost of losing some information, which can't
be recovered. Lossy compression algorithms are typically used for audio and
video files, where a loss in quality is tolerable and often not noticeable.
Lossless compression algorithms on the other hand don't compress as much, but do
not lose any data, meaning compressed information can be exactly reconstructed
back into its uncompressed form. Lossless compression algorithms are used for
data that must maintain integrity, such as binaries, text documents, and source
code.

\section{Lempel-Ziv Compression}
Abraham Lempel and Jacob Ziv published papers for two lossless compression
algorithms, LZ77 and LZ78, published in 1977 and 1978, respectively. The core
idea behind both of these compression algorithms is to represent repeated
patterns in data with using pairs which are each comprised of a code and a
symbol. A code is an unsigned 16-bit integer and a symbol is a 8-bit ASCII
character.

Assume, for example, we have some string ``$abab$''. Assume we also have a
dictionary where the key is a prefix, also known as a word, and the value is a
code that we can utilize for fast look-ups. Since codes are 16-bit unsigned
integers, we will give the dictionary a limit of $2^{16} - 1$ possible codes.
Why don't we have $2^{16}$ codes? Because we will be reserving a code to be used
as a stop code which indicates the end of our encoded data. We will define the
maximal usable code as \texttt{MAX\_CODE}, which has the value $2^{16} - 1$. The
dictionary is initialized with the empty word, or a string of zero length, at
the index \texttt{EMPTY\_CODE}, which is a macro for 1. We will specify the
first index in which a new word can be added to as the macro
\texttt{START\_CODE}, which has the value 2.

We now consider the first character: `$a$'. Since this is the first character,
we know that the string of all previously seen characters up to this point must
be the empty word; we haven't considered any characters prior to this point.  We
then append the current character `$a$' to the empty word, which yields the word
``$a$''. We check the dictionary in vain to see if we've encountered this word
before. Since we haven't yet seen this word, we will add this first word to the
dictionary and assign it the first available code of 2, or \texttt{START\_CODE}.
We set our previously seen word to be the empty word and output the pair
(\texttt{EMPTY\_CODE},\;`$a$').

We continue on, now considering the second character: `$b$'. We append this
character to our previously seen word, which yields ``$b$'' as our current word.
We again check the dictionary in vain to see if we've encountered this word
before. Since we haven't, we add this word to the dictionary and assign it the
next available code of 3. We set the previously seen word to the empty word and
output the pair (\texttt{EMPTY\_CODE},\;`$b$').

The next character we see is `$a$'. We append this character to our previously
seen word, which yields ``$a$'' as our current word. We check the dictionary to
see if we've encountered this word before. Indeed we have. We set the previously
seen word to ``$a$'' and proceed to the next character without any further
output.

We read in the last character, `$b$'. We append this character to our previously
seen word, which yields ``$ab$''. Clearly, this word isn't in the dictionary, so
pair comprised of the current symbol, `$b$', and the code of the previously
we add it and assign it the next available code of 4. What should we output? The
seen word. Since our previously seen word at this stage was ``$a$'', this code
will be 2. Thus, we output (2,\;`$b$'). To finish off compression, we output the
final pair (\texttt{STOP\_CODE},\;0). As you can imagine, this pair signals the
end of compressed data. The symbol in this final pair isn't used and the value
is of no significance. The macro \texttt{STOP\_CODE} has the value of 0.

Of course, a compression algorithm is useless without a corresponding
decompression algorithm. Assume we're reading in the output from the preceding
compression example. The output was comprised of the following pairs, in order:
(\texttt{EMPTY\_CODE},\;`$a$'), (\texttt{EMPTY\_CODE},\;`$b$'), (2,\;`$b$'),
(\texttt{STOP\_CODE},\,0). Similar to the compression algorithm, the
decompression algorithm initializes a dictionary containing only the empty word.
The catch is that the key and value for the decompressing dictionary is swapped;
each key is instead a code and each value a word. As you might imagine, the
decompression algorithm is the inverse of the compression algorithm, and thus
from the output pairs, the decompression algorithm will recreate the same
dictionary used during compression to output the decompressed data.

We consider the first pair: (\texttt{EMPTY\_CODE},\;`$a$'). We append the symbol
`$a$' to the word denoted by \texttt{EMPTY\_CODE}, which is the empty word.
Thus, the current word is ``$a$''. We add this word to the dictionary and assign
it the next available code of 2, then output the current word ``$a$''.

We consider the next pair: (\texttt{EMPTY\_CODE},\;`$b$'). We append the symbol
`$b$' to the word denoted by \texttt{EMPTY\_CODE}, which is the empty word.
Thus, the current word is ``$b$''. We add this word to the dictionary and assign
it the next available code of 3, then output the current word ``$b$''.

We now consider the next pair: (2,\;`$b$'). We append the symbol `$b$' to the
word denoted by the code 2, which we previously added to our dictionary. The
word denoted by this code is ``$a$'', whence we obtain our current word of
``$ab$''. We add this word to the dictionary and assign it the next available
code of 4, then output the current word ``$ab$''. Finally, we read in the last
pair: (\texttt{STOP\_CODE},\;0). Since the code is \texttt{STOP\_CODE}, we know
that we have finished decompression.

\begin{table}
    \caption{\textbf{Compression Example}}
    \begin{tabular}{ccc}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Initialized dictionary}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Word} & \textbf{Code} \\
                \hline
                ``'' & \texttt{EMPTY\_CODE} \\
                \hline
                     & \texttt{START\_CODE} \\
                \hline
                & 3 \\
                \hline
                & 4 \\
                \hline
                & $\ldots$ \\
                \hline
                & \texttt{MAX\_CODE} \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``a''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Word} & \textbf{Code} \\
                \hline
                ``'' & \texttt{EMPTY\_CODE} \\
                \hline
                ``$a$'' & \texttt{START\_CODE} \\
                \hline
                & 3 \\
                \hline
                & 4 \\
                \hline
                & $\ldots$ \\
                \hline
                & \texttt{MAX\_CODE} \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``b''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Word} & \textbf{Code} \\
                \hline
                ``'' & \texttt{EMPTY\_CODE} \\
                \hline
                ``$a$'' & \texttt{START\_CODE} \\
                \hline
                ``$b$'' & 3 \\
                \hline
                & 4 \\
                \hline
                & $\ldots$ \\
                \hline
                & \texttt{MAX\_CODE} \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``ab''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Word} & \textbf{Code} \\
                \hline
                ``'' & \texttt{EMPTY\_CODE} \\
                \hline
                ``$a$'' & \texttt{START\_CODE} \\
                \hline
                ``$b$'' & 3 \\
                \hline
                ``$ab$'' & 4 \\
                \hline
                & $\ldots$ \\
                \hline
                & \texttt{MAX\_CODE} \\
           \end{tabular}
        \end{minipage}
    \end{tabular}
\end{table}

\begin{table}
    \caption{\textbf{Decompression Example}}
    \begin{tabular}{ccc}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Initialized dictionary}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Code} & \textbf{Word} \\
                \hline
                \texttt{EMPTY\_CODE} & ``'' \\
                \hline
                \texttt{START\_CODE} & \\
                \hline
                3 & \\
                \hline
                4 & \\
                \hline
                $\ldots$ & \\
                \hline
                \texttt{MAX\_CODE} & \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``a''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Code} & \textbf{Word} \\
                \hline
                \texttt{EMPTY\_CODE} & ``'' \\
                \hline
                \texttt{START\_CODE} & ``$a$'' \\
                \hline
                3 & \\
                \hline
                4 & \\
                \hline
                $\ldots$ & \\
                \hline
                \texttt{MAX\_CODE} & \\
           \end{tabular}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``b''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Code} & \textbf{Word} \\
                \hline
                \texttt{EMPTY\_CODE} & ``'' \\
                \hline
                \texttt{START\_CODE} & ``$a$'' \\
                \hline
                3 & ``$b$'' \\
                \hline
                4 & \\
                \hline
                $\ldots$ & \\
                \hline
                \texttt{MAX\_CODE} & \\
           \end{tabular}
           \label{ahaha}
        \end{minipage}
        \begin{minipage}{.24\textwidth}
            \caption{\textbf{Adding ``ab''}}
            \centering
            \begin{tabular}{c|c}
                \textbf{Code} & \textbf{Word} \\
                \hline
                \texttt{EMPTY\_CODE} & ``'' \\
                \hline
                \texttt{START\_CODE} & ``$a$'' \\
                \hline
                3 & ``$b$'' \\
                \hline
                4 & ``$ab$'' \\
                \hline
                $\ldots$ & \\
                \hline
                \texttt{MAX\_CODE} & \\
           \end{tabular}
        \end{minipage}
    \end{tabular}
\end{table}


If the basic idea behind the compression and decompression algorithms do not
immediately make sense to you, or if you desire a more visual representation of
how the algorithms work, make sure to attend section and get help early! Things
will not get easier as time goes on.

\section{Your Task}

Your task is to implement two programs called \texttt{encode} and
\texttt{decode} which perform LZ78 compression and decompression, respectively.
The requirements for your programs are as follows:

\begin{enumerate}
    \item \texttt{encode} can compress any file, text or binary.

    \item \texttt{decode} can decompress any file, text or binary, that was
        compressed with \texttt{encode}.

    \item Both operate on both little and big endian systems.
        \emph{Interoperability is required}.

    \item Both use variable bit-length codes.

    \item Both perform read and writes in efficient blocks of 4KB.
\end{enumerate}

\section{Specifics}

You will need to implement some new ADTs for this assignment: an ADT for tries
and an ADT for words. In addition to these new ADTS, you will need to
be concerned about variable-length codes, I/O, and endianness.

\subsection{Tries}
The most costly part of compression is checking for existing prefixes, or words.
You could utilize a hash table, or just an array to store words, but that
wouldn't be optimal, as many of the words you need to store are prefixes of
other words. Instead you choose to utilize a \emph{trie}.

A trie\footnote{Edward Fredkin, ``{T}rie memory.'' \emph{Communications of the
ACM} 3, no. 9 (1960): 490--499.} is an efficient information re-\emph{trie}-val
data structure, commonly known as a prefix tree. Each node in a trie represents
a symbol, or a character, and contains $n$ child nodes, where $n$ is the size of
the alphabet you are using. In most cases, the alphabet used is the set of ASCII
characters, so $n = 256$. You will use a trie during compression to store words.

\begin{center}
    \tikzset{
        sibling distance=1.2cm, level distance=0.8cm,
        split/.style={
            draw, rectangle split, rectangle split parts=2,draw,inner
            sep=0pt,rectangle split horizontal,minimum size=0ex,text
            width=1ex,align=center,rectangle split part align=base
        },
        boxed/.style={draw,minimum size=3ex,inner sep=0pt,align=center},
        edge from parent/.style={draw, edge from parent path={[->,thick]
        (\tikzparentnode)  -- ($(\tikzchildnode.north) + 2*(0pt,1pt)$) }}
    }

    \begin{tikzpicture}
        \Tree
        [.\node[boxed] (S1) {\nodepart{one}\texttt{ ROOT }};
            [.\node[boxed] (L1) {\nodepart{one}b};
                [.\node[boxed] (L2) {y}; ]
            ]
            [.\node[boxed] (M1) {\nodepart{one}s};
                [.\node[boxed] (L3) {e};
                    [.\node[boxed] (L4) {a};]
                    [.\node[boxed] (R4) {l};
                        [.\node[boxed] (M2) {l};
                            [.\node[boxed] (M3) {s}; ]
                        ]
                    ]
                ]
                [.\node[boxed] (R3) {h};
                    [.\node[boxed] (L5) {e};
                        [.\node[boxed] (M4) {l};
                            [.\node[boxed] (M5) {l};
                                [.\node[boxed] (M6) {s}; ]
                            ]
                        ]
                    ]
                    [.\node[boxed] (R5) {o};
                        [.\node[boxed] (M7) {r};
                            [.\node[boxed] (M8) {e};]
                        ]
                    ]
                ]
            ]
            [.\node[boxed] (R1) {\nodepart{one}t};
                [.\node[boxed] (R2) {h};
                    [.\node[boxed] (M9) {e}; ]
                ]
            ]
        ]
    \end{tikzpicture}
\end{center}

Above is an example of a trie containing the following words: ``$She$'',
``$sells$'', ``$sea$'', ``$shells$'', ``$by$'', ``$the$'', ``$sea$'',
``$shore$''. Searching for a word in the trie means stepping down for each
symbol in the word, starting from the root. Stepping down the trie is simply
checking if the current node we have traversed to has a child node representing
the symbol we are looking for, and setting the current node to be the child node
if it does exist. Thus, to find ``$sea$'', we would start from the trie's root
and step down to `$s$', then `$e$', then `$a$'.  If any symbol is missing, or
the end of the trie is reached without fully matching a word, while stepping
through the trie, then the word is not in the trie.  You \emph{must} follow the
specification shown below when implementing your trie ADT.

\begin{lstlisting}[title=trie.h]
#ifndef __TRIE_H__
#define __TRIE_H__

#include "util.h"
#include <inttypes.h>

#define ALPHABET 256

typedef struct TrieNode TrieNode;

//
// Struct definition of a TrieNode.
//
// children:  Each TrieNode has ALPHABET number of children.
// code:      Unique code for a TrieNode.
//
struct TrieNode {
  TrieNode *children[ALPHABET];
  uint16_t code;
};

//
// Constructor for a TrieNode.
//
// code:    Code of the constructed TrieNode.
// returns: Pointer to a TrieNode that has been allocated memory.
//
TrieNode *trie_node_create(uint16_t code);

//
// Destructor for a TrieNode.
//
// n:       TrieNode to free allocated memory for.
// returns: Void.
//
void trie_node_delete(TrieNode *n);

//
// Initializes a Trie: a root TrieNode with the code EMPTY_CODE.
//
// returns: Pointer to the root of a Trie.
//
TrieNode *trie_create(void);

//
// Resets a Trie to just the root TrieNode.
//
// root:    Root of the Trie to reset.
// returns: Void.
//
void trie_reset(TrieNode *root);

//
// Deletes a sub-Trie starting from the sub-Trie's root.
//
// n:       Root of the sub-Trie to delete.
// returns: Void.
//
void trie_delete(TrieNode *n);

//
// Returns a pointer to the child TrieNode reprsenting the symbol sym.
// If the symbol doesn't exist, NULL is returned.
//
// n:       TrieNode to step from.
// sym:     Symbol to check for.
// returns: Pointer to the TrieNode representing the symbol.
//
TrieNode *trie_step(TrieNode *n, uint8_t sym);

#endif
\end{lstlisting}

The \texttt{TrieNode struct} will have the three fields shown above. Each trie
node has an array of 256 pointers to trie nodes as children, one for each ASCII
character. It should be easy to see how this simplifies searching for the next
character in a word in the trie. The \texttt{code} field stores the 16-bit code
for the word that ends with the trie node containing the code. This means that
the code for some word ``$abc$'' would be contained in the trie node for `$c$'.
Note that there isn't a field that indicates what character a trie node
represents. This is because the trie node's index in its parent's array of child
nodes indicates what character it represents. The \texttt{trie\_step()} function
will be repeatedly called to check if a word exists in the trie. A word only
exists if the trie node returned by the last step corresponding to the last
character in the word isn't \texttt{NULL}.

\subsection{Word Tables}

Although compression can be performed using a trie, decompression still needs to
use a look-up table for quick code to word translation. This look-up table will
be defined as a new \texttt{struct} called a \texttt{WordTable}. Since we can
only have $2^{16}-1$ codes, one of which is reserved as a stop code, we can use
a fixed word table size of \texttt{UINT16\_MAX}, where \texttt{UINT16\_MAX} is a
macro defined in \texttt{inttypes.h} as the maximum value of a unsigned 16-bit
integer. Hint: this has the exact same value as \texttt{MAX\_CODE}, which we
defined earlier.  Why aren't we using hash tables to store words? Because there
is a \emph{finite} number of codes. Each index of this word table will be a new
\texttt{struct} called a \texttt{Word}. You will store words in byte arrays, or
arrays of \texttt{uint8\_t}. This is because strings in \textbf{C} are
null-terminated, and problems with compression occur if a binary file is being
compressed and contains null characters that are placed into strings.  Since we
need to know how long a word is, a \texttt{Word} will also have a field for
storing the length of the byte array, since we can't use \texttt{string.h}
functions like \texttt{strlen()} on byte arrays. You \emph {must} use the
following specification for the new \texttt{Word} ADT.

\begin{lstlisting}
#ifndef __WORD_H__
#define __WORD_H__

#include <inttypes.h>

//
// Struct definition of a Word.
//
// syms:  A Word holds an array of symbols, stored as bytes in an array.
// len:   Length of the array storing the symbols a Word represents.
//
typedef struct Word {
  uint8_t *syms;
  uint32_t len;
} Word;

//
// Define an array of Words as a WordTable.
//
typedef Word * WordTable;

//
// Constructor for a word.
//
// syms:    Array of symbols a Word represents.
// len:     Length of the array of symbols.
// returns: Pointer to a Word that has been allocated memory.
//
Word *word_create(uint8_t *syms, uint64_t len);

//
// Constructs a new Word from the specified Word appended with a symbol.
// The Word specified to append to may be empty.
// If the above is the case, the new Word should contain only the symbol.
//
// w:       Word to append to.
// sym:     Symbol to append.
// returns: New Word which represents the result of appending.
//
Word *word_append_sym(Word *w, uint8_t sym);

//
// Destructor for a Word.
//
// w:       Word to free memory for.
// returns: Void.
//
void word_delete(Word *w);

//
// Creates a new WordTable, which is an array of Words.
// A WordTable has a pre-defined size of MAX_CODE (UINT16_MAX - 1).
// This is because codes are 16-bit integers.
// A WordTable is initialized with a single Word at index EMPTY_CODE.
// This Word represents the empty word, a string of length of zero.
//
// returns: Initialized WordTable.
//
WordTable *wt_create(void);

//
// Resets a WordTable to having just the empty Word.
//
// wt:      WordTable to reset.
// returns: Void.
//
void wt_reset(WordTable *wt);

//
// Deletes an entire WordTable.
// All Words in the WordTable must be deleted as well.
//
// wt:      WordTable to free memory for.
// returns: Void.
//
void wt_delete(WordTable *wt);

#endif
\end{lstlisting}

\subsection{Codes}

It is a requirement that your programs, \texttt{encode} and \texttt{decode},
be able to read and write pairs containing variable bit-length codes. As an
example, assume we are going to write the pair (13,\;`$a$'). What is the minimum
number of bits needed to represent 13? We can easily calculate the minimum
number of bits needed to represent any integer $x \geq 1$ using the formula
$\lfloor \log_2 (x) \rfloor + 1$. The only edge case is with 0, whose bit-length
is 1. Thus, we calculate that the minimum number of bits needed to represent 13,
or the bit-length of 13, to be 4. That being said, in practice, the bit-length of
the code in the pair you're going output wouldn't be the bit-length of the code
itself, but rather the bit-length of the \emph{next available code} assignable, as
described in the earlier compression example. The reason for this is because
decompression \emph{must} know at all times the bit-length of the code it is going
to read. Because the dictionary constructed by decompression contains exactly
the words and codes contained by the trie constructed by compression, it is
evident that, by using the bit-length of the next available code, that compression
and decompression will agree on the variable bit-lengths of codes. Note that only
codes have variable bit-lengths: symbols in a pair are always 8 bits.

As an example, assume we are going to output the pair (13,\;`$a$'), and the next
available code assignable in our dictionary is 64. We will need to convert this
pair to binary, starting with the code. As stated earlier, the bit-length of the
code is the bit-length of the next available code. We calculate that the bit-length
of 64 is 7. We start from the least significant bit of our code, 13, and
construct the code portion of the pair's binary representation:
\texttt{1011000}. Notice the padded zeroes and that the binary is reversed.
Zeroes are padded because the bit-length of 64 is 7, while the bit-length of 13 is
4, which is why there are three padded zeroes. In the same fashion, we start
from the least significant bit of our symbol, `$a$', and add the symbol portion
of the pair's binary representation to the previous code portion, which yields
\texttt{10110001000011}, since the ASCII value of `$a$' is 97.

Now assume that we are reading in the binary \texttt{10110001000011} and
converting that back into a pair. We know that the next available code
assignable by compression and decompression are the same at every step. Thus, we
know that compression must have output the pair's code with the bit-length of 64,
which is 7. We go through the first 7 bits of the binary: \texttt{1},
\texttt{0}, \texttt{1}, \texttt{1}, \texttt{0}, \texttt{0}, and \texttt{0},
summing up the bits as we go, simulating how positional numbering systems work.
This means we perform $1 \cdot 2^0 + 0 \cdot 2^1 + 1 \cdot 2^2 + 1 \cdot 2^3 +
0 \cdot 2^4 + 0 \cdot 2^5 + 0 \cdot 2^6 = 13$, exactly the code output by
compression. We do the same for the remaining 8 bits to reconstruct the symbol.

\begin{lstlisting}[title=code.h]
#ifndef __CODE_H__
#define __CODE_H__

#include <inttypes.h>

#define STOP_CODE   0               // Signals end of decoding/decoding.
#define EMPTY_CODE  1               // Code denoting the empty Word.
#define START_CODE  2               // Starting code of new Words.
#define MAX_CODE    UINT16_MAX      // Maximum code.

#endif
\end{lstlisting}

\subsection{I/O}

It is also a requirement that your programs, \texttt{encode} and
\texttt{decode}, perform efficient I/O. Reads and writes will be done 4KB, or a
block, at a time, which implicitly requires that you buffer I/O. Buffering is
the act of storing data into a buffer, which you can think of as an array of
bytes. Below is an I/O module that you are required to implement for the
assignment.

\begin{lstlisting}[title=io.h]
#ifndef __IO_H__
#define __IO_H__

#include "word.h"
#include <inttypes.h>
#include <stdbool.h>

#define MAGIC 0x8badbeef    // Program's magic number.

//
// Struct definition of a FileHeader.
//
// magic:       Magic number indicating a file compressed by this program.
// protection:  Protection/permissions of the original, uncompressed file.
//
typedef struct FileHeader {
  uint32_t magic;
  uint16_t protection;
} FileHeader;

//
// Reads in sizeof(FileHeader) bytes from the input file.
// These bytes are read into the supplied FileHeader, header.
// Endianness is swapped if byte order isn't little endian.
//
// infile:  File descriptor of input file to read header from.
// header:  Pointer to memory where the bytes of the read header should go.
// returns: Void.
//
void read_header(int infile, FileHeader *header);

//
// Writes sizeof(FileHeader) bytes to the output file.
// These bytes are from the supplied FileHeader, header.
// Endianness is swapped if byte order isn't little endian.
//
// outfile: File descriptor of output file to write header to.
// header:  Pointer to the header to write out.
// returns: Void.
//
void write_header(int outfile, FileHeader *header);

//
// "Reads" a symbol from the input file.
// The "read" symbol is placed into the pointer to sym. (e.g. *sym = val)
// In reality, a block of symbols is read into a buffer.
// An index keeps track of the currently read symbol in the buffer.
// Once all symbols are processed, another block is read.
// If less than a block is read, the end of the buffer is updated.
// Returns true if there are symbols to be read, false otherwise.
//
// infile:  File descriptor of input file to read symbols from.
// sym:     Pointer to memory which stores the read symbol.
// returns: True if there are symbols to be read, false otherwise.
//
bool read_sym(int infile, uint8_t *sym);

//
// Buffers a pair. A pair is comprised of a code and a symbol.
// The bits of the code are buffered first, starting from the LSB.
// The bits of the symbol are buffered next, also starting from the LSB.
// The code buffered has a bit-length of bitlen.
// The buffer is written out whenever it is filled.
//
// outfile: File descriptor of the output file to write to.
// code     Code of the pair to buffer.
// sym:     Symbol of the pair to buffer.
// bitlen:  Number of bits of the code to buffer.
// returns: Void.
//
void buffer_pair(int outfile, uint16_t code, uint8_t sym, uint8_t bitlen);

//
// Writes out any remaining pairs of symbols and codes to the output file.
//
// outfile: File descriptor of the output file to write to.
// returns: Void.
//
void flush_pairs(int outfile);

//
// "Reads" a pair (code and symbol) from the input file.
// The "read" code is placed in the pointer to code (e.g. *code = val)
// The "read" symbol is placed in the pointer to sym (e.g. *sym = val).
// In reality, a block of pairs is read into a buffer.
// An index keeps track of the current bit in the buffer.
// Once all bits have been processed, another block is read.
// The first bitlen bits are the code, starting from the LSB.
// The last 8 bits of the pair are the symbol, starting from the LSB.
// Returns true if there are pairs left to read in the buffer, else false.
// There are pairs left to read if the read code is not STOP_CODE.
//
// infile:  File descriptor of the input file to read from.
// code:    Pointer to memory which stores the read code.
// sym:     Pointer to memory which stores the read symbol.
// bitlen:  Length in bits of the code to read.
// returns: True if there are pairs left to read, false otherwise.
//
bool read_pair(int infile, uint16_t *code, uint8_t *sym, uint8_t bitlen);

//
// Buffers a Word, or more specifically, the symbols of a Word.
// Each symbol of the Word is placed into a buffer.
// The buffer is written out when it is filled.
//
// outfile: File descriptor of the output file to write to.
// w:       Word to buffer.
// returns: Void.
//
void buffer_word(int outfile, Word *w);

//
// Writes out any remaining symbols in the buffer.
//
// outfile: File descriptor of the output file to write to.
// returns: Void.
//
void flush_words(int outfile);

#endif

\end{lstlisting}

Notice that there is a \texttt{struct} definition in the module interface. That
is the \texttt{struct} definition for the file header, which contains the magic
number for your program and the protection bit mask for the original file.  The
file header is the first thing that appears in a compressed file. The magic
number field, \texttt{magic}, serves as a unique identifier for files compressed
by \texttt{encode}. \texttt{decode} should only be able to decompress files
which have the correct magic number. This magic number is \texttt{0x8badbeef}.
The function \texttt{read\_header()} reads in the header and verifies the magic
number.  The protection bit mask comes from the original file. The output file
in which you write to must have the same protection bits as the original file.
Before writing the file header to the compressed file using
\texttt{write\_header()}, you must swap the endianness of the fields if
necessary since \emph{interoperability is required}. If your program is run on a
system using big endian, the fields must be swapped to little endian, since
little endian is canonical. Here is another module specifically for handling
endianness:

\begin{lstlisting}[title=endian.h]
#ifndef __ENDIAN_H__
#define __ENDIAN_H__

#include <inttypes.h>
#include <stdbool.h>

//
// Checks if the order of bytes on the system is big endian.
//
static inline bool is_big(void) {
  union {
    uint8_t bytes[2];
    uint16_t word;
  } test;
  test.word = 0xFF00;
  return test.bytes[0];
}

//
// Checks if the order of bytes on the system is little endian.
//
static inline bool is_little(void) {
  return !is_big();
}

//
// Swaps the endianness of a uint16_t.
//
// x:  The uint16_t.
//
static inline uint16_t swap16(uint16_t x) {
  uint16_t result = 0;
  result |= (x & 0x00FF) << 8;
  result |= (x & 0xFF00) >> 8;
  return result;
}

//
// Swaps the endianness of a uint32_t.
//
// x:  The uint32_t.
//
static inline uint32_t swap32(uint32_t x) {
  uint32_t result = 0;
  result |= (x & 0x000000FF) << 24;
  result |= (x & 0x0000FF00) << 8;
  result |= (x & 0x00FF0000) >> 8;
  result |= (x & 0xFF000000) >> 24;
  return result;
}

//
// Swaps the endianness of a uint64_t.
//
// x:  The uint64_t.
//
static inline uint64_t swap64(uint64_t x) {
  uint64_t result = 0;
  result |= (x & 0x00000000000000FF) << 56;
  result |= (x & 0x000000000000FF00) << 40;
  result |= (x & 0x0000000000FF0000) << 24;
  result |= (x & 0x00000000FF000000) << 8;
  result |= (x & 0x000000FF00000000) >> 8;
  result |= (x & 0x0000FF0000000000) >> 24;
  result |= (x & 0x00FF000000000000) >> 40;
  result |= (x & 0xFF00000000000000) >> 56;
  return result;
}

#endif
\end{lstlisting}

All reads and writes in this program must be done using the system calls
\texttt{read()} and \texttt{write()}, which means that you must use the system
calls \texttt{open()} and \texttt{close()} to get your file descriptors. As
stated earlier, all reads and writes must be performed in efficient blocks of
4KB. You will want to use two static 4KB uint8\_t arrays to serve as buffers:
one to store binary pairs and the other to store characters. Each of these
buffers should have an index, or a variable, to keep track of the current byte
or bit that has been processed.

\section{Program Options}

Your \texttt{encode} program must support the following \texttt{getopt()}
options:

\begin{itemize}
    \item \texttt{-v} : Display compression statistics

    \item \texttt{-i <input>} : Specify input to compress (\texttt{stdin} by
        default)

    \item \texttt{-o <output>} : Specify output of compressed input
        (\texttt{stdout} by default)
\end{itemize}

Your \texttt{decode} program must support the following \texttt{getopt()}
options:

\begin{itemize}
    \item \texttt{-v} : Display decompression statistics

    \item \texttt{-i <input>} : Specify input to decompress (\texttt{stdin} by
        default)

    \item \texttt{-o <output>} : Specify output of decompressed input
        (\texttt{stdout} by default)
\end{itemize}

The verbose option enables a flag to print out informative statistics about the
compression or decompression that is performed. These statistics include the
compressed file size, the uncompressed file size, and the compression ratio.
The formula for the compression ratio is $100\times(1-(\text{compressed size} /
\text{uncompressed size}))$. The verbose output of both \texttt{encode} and
\texttt{decode} must match the following:

\begin{lstlisting}
Compressed file size: X bytes
Uncompressed file size: X bytes
Compression ratio: XX.XX%
\end{lstlisting}

\section{Compression}
The following steps for compression will refer to the input file descriptor to
compress as \texttt{infile} and the compressed output file descriptor as
\texttt{outfile}.

\begin{enumerate}
    \item Open \texttt{infile} with \texttt{open()}. If an error occurs, print a
        helpful message and exit with a status code indicating that an error
        occurred. \texttt{infile} should be \texttt{stdin} if an input file
        wasn't specified.

    \item The first thing in \texttt{outfile} must be the file header, as
        defined in the file \texttt{io.h}. The magic number in the header must
        be \texttt{0x8badbeef}. The file size and the protection bit mask you
        will obtain using \texttt{fstat()}. See the man page on it for details.

    \item Open \texttt{outfile} using \texttt{open()}. The permissions for
        \texttt{outfile} should match the protection bits as set in your file
        header. Any errors with opening \texttt{outfile} should be handled like
        with \texttt{infile}. \texttt{outfile} should be \texttt{stdout} if an
        output file wasn't specified.

    \item Write the filled out file header to \texttt{outfile} using
        \texttt{write\_header()}. This means writing out the \texttt{struct}
        itself to the file, as described in the comment block of the function.

    \item Create a trie. The trie initially has no children and consists solely
        of the root. The code stored by this root trie node should be
        \texttt{EMPTY\_CODE} to denote the empty word. You will need to make a
        copy of the root node and use the copy to step through the trie to check
        for existing prefixes. This root node copy will be referred to as
        \texttt{curr\_node}. The reason a copy is needed is that you will
        eventually need to reset whatever trie node you've stepped to back to
        the top of the trie, so using a copy lets you use the root node as a
        base to return to.

    \item You will need a monotonic counter to keep track of the next available
        code. This counter should start at \texttt{START\_CODE}, as defined in
        the supplied \texttt{code.h} file. The counter should be a
        \texttt{uint16\_t} since the codes used are unsigned 16-bit integers.
        This will be referred to as \texttt{next\_code}.

    \item You will also need two variables to keep track of the previous trie
        node and previously read symbol. We will refer to these as
        \texttt{prev\_node} and \texttt{prev\_sym}, respectively.

    \item Use \texttt{read\_sym()} in a loop to read in all the symbols from
        \texttt{infile}. Your loop should break when \texttt{read\_sym()}
        returns false. For each symbol read in, call it \texttt{curr\_sym},
        perform the following:

        \begin{enumerate}
            \item Set \texttt{next\_node} to be \texttt{trie\_step(curr\_node,
                curr\_sym)}, stepping down from the current node to the
                currently read symbol.

            \item If \texttt{next\_node} is not \texttt{NULL}, that means we
                have seen the current prefix. Set \texttt{prev\_node} to be
                \texttt{curr\_node} and then \texttt{curr\_node} to be
                \texttt{next\_node}.

            \item Else, since \texttt{next\_node} is \texttt{NULL}, we know we
                have not encountered the current prefix. We buffer the pair
                (\texttt{curr\_node->code}, \texttt{curr\_sym}), where the
                bit-length of the buffered code is the bit-length of
                \texttt{next\_code}. We now add the current prefix to the trie.
                Let \texttt{curr\_node->children[curr\_sym]} be a new trie node
                whose code is \texttt{next\_code}. Reset \texttt{curr\_node} to
                point at the root of the trie and increment the value of
                \texttt{next\_code}.

            \item Check if \texttt{next\_code} is equal to \texttt{MAX\_CODE}.
                If it is, use \texttt{trie\_reset()} to reset the trie to just
                having the root node. This reset is necessary since we have a
                finite number of codes.

            \item Update \texttt{prev\_sym} to be \texttt{curr\_sym}.
        \end{enumerate}

    \item After processing all the characters in \texttt{infile}, check if
        \texttt{curr\_node} points to the root trie node. If it does not, it
        means we were still matching a prefix. Buffer the pair
        (\texttt{prev\_node->code}, \texttt{prev\_sym}). The bit-length of the
        code buffered should be the bit-length of \texttt{next\_code}. Make sure
        to increment \texttt{next\_code} and that it stays within the limit of
        \texttt{MAX\_CODE}. Hint: use the modulo operator.

    \item Buffer the pair (\texttt{STOP\_CODE}, 0) to signal the end of
        compressed output. Again, the bit-length of code buffered should be the
        bit-length of \texttt{next\_code}.

    \item Make sure to use \texttt{flush\_pairs()} to flush any unwritten,
        buffered pairs.

    \item Use \texttt{close()} to close \texttt{infile} and \texttt{outfile}.
\end{enumerate}

\section{Decompression}

The following steps for decompression will refer to the input file to decompress
as \texttt{infile} and the uncompressed output file as \texttt{outfile}.

\begin{enumerate}
    \item Open \texttt{infile} with \texttt{open()}. If an error occurs, print a
        helpful message and exit with a status code indicating that an error
        occurred. \texttt{infile} should be \texttt{stdin} if an input file
        wasn't specified.

    \item Read in the file header with \texttt{read\_header()}, which also
        verifies the magic number. If the magic number is verified then
        decompression is good to go and you now have a header which contains the
        original protection bit mask.

    \item Open \texttt{outfile} using \texttt{open()}. The permissions for
        \texttt{outfile} should match the protection bits as set in your file
        header that you just read. Any errors with opening \texttt{outfile}
        should be handled like with \texttt{infile}. \texttt{outfile} should be
        \texttt{stdout} if an output file wasn't specified.

    \item Create a new word table with \texttt{wt\_create()} and make sure each
        of its entries are set to \texttt{NULL}. Initialize the table to have
        just the empty word, a word of length 0, at the index
        \texttt{EMPTY\_CODE}. We will refer to this table as \texttt{table}.

    \item You will need two \texttt{uint16\_t} to keep track of the
        current code and next code. These will be referred to as
        \texttt{curr\_code} and \texttt{next\_code}, respectively.
        \texttt{next\_code} should be initialized as \texttt{START\_CODE} and
        functions exactly the same as the monotonic counter used during
        compression, which was also called \texttt{next\_code}.

    \item Use \texttt{read\_pair()} in a loop to read all the pairs from
        \texttt{infile}. We will refer to the code and symbol from each read
        pair as \texttt{curr\_code} and \texttt{curr\_sym}, respectively. The
        bit-length of the code to read is the bit-length of \texttt{next\_code}. The
        loop breaks when the code read is \texttt{STOP\_CODE}. For each read
        pair, perform the following:

        \begin{enumerate}
            \item As seen in the decompression example, we will need to append
                the read symbol with the word denoted by the read code and add
                the result to \texttt{table} at the index \texttt{next\_code}.
                The word denoted by the read code is stored in
                \texttt{table[curr\_code]}. We will append
                \texttt{table[curr\_code]} and \texttt{curr\_sym} using
                \texttt{word\_append\_sym()}.

            \item Buffer the word that we just constructed and added to the
                table with \texttt{buffer\_word()}. This word should have been
                stored in \texttt{table[next\_code]}.

            \item Increment \texttt{next\_code} and check if it equals
                \texttt{MAX\_CODE}. If it has, reset the table using
                \texttt{wt\_reset()} and set \texttt{next\_code} to be
                \texttt{START\_CODE}. This mimics the resetting of the trie
                during compression.
        \end{enumerate}

    \item Flush any buffered words using \texttt{flush\_words()}.

    \item Close \texttt{infile} and \texttt{outfile} with \texttt{close()}.
\end{enumerate}


\section{LZ78 Algorithm Pseudocode}

\subsection{Compression}

\begin{codebox}
    \Procname{\proc{Compress}(\id{infile}, \id{outfile})}
    \li \id{root} $\gets$ \proc{trie\_create}()
    \li \id{curr\_node} $\gets$ \id{root}
    \li \id{prev\_node} $\gets$ \const{null}
    \li \id{curr\_sym} $\gets$ 0
    \li \id{prev\_sym} $\gets$ 0
    \li \id{next\_code} $\gets$ \const{start\_code}
    \li \While \proc{read\_sym}(\id{infile}, \id{\&curr\_sym}) \kw{is} \const{true}
    \li \Then \id{next\_node} $\gets$ \proc{trie\_step}(\id{curr\_node},
              \id{curr\_sym})
              \li     \If \id{next\_node} \kw{is not} \const{null}
    \li     \Then \id{prev\_node} $\gets$ \id{curr\_node}
    \li           \id{curr\_node} $\gets$ \id{next\_node}
    \li     \Else
    \li           \proc{buffer\_pair}(\id{outfile},
                  \attrib{\id{curr\_node}}{code}, \id{curr\_sym},
                  \proc{bit-length}(\id{next\_code}))
    \li           \attrib{\id{curr\_node}}{children[curr\_sym]} $\gets$
                    \proc{trie\_node\_create}(\id{next\_code})
    \li           \id{curr\_node} $\gets$ \id{root}
    \li \id{next\_code} $\gets$ \id{next\_code} + 1
            \End
            \li     \If \id{next\_code} \kw{is} \const{max\_code}
    \li     \Then \proc{trie\_reset}(\id{root})
    \li           \id{curr\_node} $\gets$ \id{root}
    \li           \id{next\_code} $\gets$ \const{start\_code}
            \End
    \li     \id{prev\_sym} $\gets$ \id{curr\_sym}
        \End
        \li \If \id{curr\_node} \kw{is not} \id{root}
    \li \Then \proc{buffer\_pair}(\id{outfile},
    \attrib{\id{prev\_node}}{code}, \id{prev\_sym},
    \proc{bit-length}(\id{next\_code}))
    \li $\id{next\_code} \gets (\id{next\_code} + 1) \;\%\;\const{max\_code}$
        \End
        \li \proc{buffer\_pair}(\id{outfile}, \const{stop\_code}, 0,
        \proc{bit-length}(\id{next\_code}))
        \li \proc{flush\_pairs}(\id{outfile})
\end{codebox}

\subsection{Decompression}

\begin{codebox}
    \Procname{\proc{Decompress}(\id{infile}, \id{outfile})}
    \li \id{table} $\gets$ \proc{wt\_create}()
    \li \id{curr\_sym} $\gets$ 0
    \li \id{curr\_code} $\gets$ 0
    \li \id{next\_code} $\gets$ \const{start\_code}
    \li \While \proc{read\_pair}(\id{infile}, \id{\&curr\_code},
    \id{\&curr\_sym}, \proc{bit-length}(\id{next\_code})) \kw{is} \const{true}
    \li \Then
              \id{table}[\id{next\_code}] $\gets$
              \proc{word\_append\_sym}(\id{table}[\id{curr\_code}],
              \id{curr\_sym})
              \li \proc{\id{buffer\_word}}(\id{outfile},
              \id{table}[\id{next\_code}])
              \li \id{next\_code} $\gets$ \id{next\_code} + 1
        \li     \If \id{next\_code} \kw{is} \const{max\_code}
    \li     \Then \proc{wt\_reset}(\id{table})
    \li           \id{next\_code} $\gets$ \const{start\_code}
                \End
        \End
    \li \proc{flush\_words}(\id{outfile})
\end{codebox}

\newpage

\section{Deliverables}
You will need to turn in:

\begin{enumerate}
    \item \texttt{Makefile}:
        \begin{itemize}
            \item \texttt{CFLAGS=-Wall -Wextra -Werror -Wpedantic -std=c99} must
                be included.

            \item \texttt{CC=clang} must be specified.

            \item \texttt{make clean} must remove all files that are compiler
                generated.

            \item \texttt{make infer} must run \texttt{infer} on your program.
                Complaints generated by \texttt{infer} must be either fixed or
                explained in your \texttt{README}.

            \item \texttt{make encode} should build your \texttt{encode}
                program.

            \item \texttt{make decode} should build your \texttt{decode}
                program.

            \item \texttt{make} should build both \texttt{encode} and
                \texttt{decode}, as should \texttt{make all}.

            \item Your programs should have no memory leaks.
        \end{itemize}

    \item Your programs \emph{must} have the following source and header files:
        \begin{itemize}
            \item \texttt{encode.c} : contains the \texttt{main()} function for
                the \texttt{encode} program.

            \item \texttt{decode.c} : contains the \texttt{main()} function for
                the \texttt{decode} program.

            \item \texttt{trie.c} and \texttt{trie.h} : the source and header
                file for the Trie ADT.

            \item \texttt{word.c} and \texttt{word.h} : the source and header
                file for the Word ADT.

            \item \texttt{io.c} and \texttt{io.h} : the source and header for
                the I/O module.

            \item \texttt{endian.h}: the header file for the endianness module.

            \item \texttt{code.h}: the header file containing macros for special
                codes.
        \end{itemize}

    \item You may have other source and header files, but
        \emph{do not try to be overly clever}.

    \item \texttt{README.md}: This must be in markdown. This should
        describe how to use your program and Makefile. This also contains any
        explanations for complaints generated by \texttt{infer}.

    \item \texttt{DESIGN.pdf}: This must be a PDF. The design document should
        describe your design for your program with enough detail that a
        sufficiently knowledgeable programmer would be able to replicate your
        implementation. This does not mean copying your entire program in
        verbatim. You should instead describe how your program works with
        supporting pseudo-code.

    \item Working \texttt{encode} and \texttt{decode} programs, along with test
        files, will be supplied in the directory \verb+~euchou/LZ78+ on
        \texttt{unix.ucsc.edu}.
\end{enumerate}


\section{Submission}

To submit your assignment, refer back to \texttt{assignment0} for the steps on
how to submit your assignment through \texttt{git}. Remember:
\emph{add, commit,} and \emph{push}!

\textcolor{red}{Your assignment is turned in \emph{only} after you have pushed.
If you forget to push, you have not turned in your assignment and you will get
a \emph{zero}. ``I forgot to push'' is not a valid excuse. It is \emph{highly}
recommended to commit and push your changes \emph{often}.}

\end{document}
